The ArachneApe Plugin
=====================

This is a default plugin to provide the base-level of features. This allows the code to have a fall-back when the user does not specify a plugin. The use of the word `plugin` in the module name seems redundant, but I am trying to avoid namespace problems since the base package is named ``arachneape``.

<<name='imports', echo=False>>=
# python standard library
import re
from collections import OrderedDict
# this package
from arachneape.interface.arguments import ArgumentClinic
from arachneape.infrastructure.hortator import TheHortator
from arachneape.components.dummy.dummy import DummyClass
from arachneape.infrastructure.theoperator import OperatorError
from base_plugin import BasePlugin
@
<<name='constants', echo=False>>=
CONFIGURATION = '''[ARACHNEAPE]
# the section names are just identifiers
# they will be executed in alphabetical order
<section_name_1> = <comma-separated-list of plugins>
<section_name_2> = <comma-separated-list of plugins>
...
<section_name_n> = <comma-separated-list of plugins>                        
'''
@
<<name='check_weave', echo=False>>=
output_documentation = __name__ == '__builtin__'
@

.. uml::

   ArachneApe -|> BasePlugin
   ArachneApe o- HelpPage
   ArachneApe o- TheHortator

.. autosummary::
   :toctree: api

   ArachneApe
   ArachneApe.help
   ArachneApe.product
   ArachneApe.config

<<name='ArachneApe', echo=False>>=
EXAMPLES = '''
arachneape run ape.ini
arachneape help
arachneape fetch
arachneape list'''

class ArachneApe(BasePlugin):
    """
    The default plugin
    """
    def __init__(self, *args, **kwargs):
        super(ArachneApe, self).__init__(*args, **kwargs)
        self._arguments = None
        return

    @property
    def arguments(self):
        """
        The ArgumentClinic
        """
        if self._arguments is None:
            self._arguments = ArgumentClinic()
            self._arguments.add_arguments()
            self._arguments.add_subparsers()
        return self._arguments

    @property
    def sections(self):
        """
        An ordered dictionary for the HelpPage
        """
        if self._sections is None:
            bold = '{bold}'
            reset = '{reset}'
            
            name = __package__.split('.')[0]
            bold_name = bold + name + reset
            program = name + '[.\w]*'
            expression = re.compile(program)
            
            arg_string = expression.sub(name,
                                        self.arguments.parser.format_usage().replace('usage: ', ''))
            
            # the sub-parsers are listed in curly braces, breaking the text-formatting
            arg_string = arg_string.replace('{', '{{')
            arg_string = arg_string.replace('}', '}}')
            arg_string = arg_string.replace(name, bold_name)
            subs = (self.arguments.runner, self.arguments.fetcher, self.arguments.lister,
                    self.arguments.checker, self.arguments.helper)
            for sub in subs:
                arg_string +=  expression.sub(bold_name,
                                              sub.format_usage().replace('usage: ', ''))
            
            self._sections = OrderedDict()
            self._sections['Name'] = '{blue}' + name + reset + ' -- a plugin-based code runner'
            self._sections['Synopsis'] = arg_string
            self._sections['Description'] = bold_name + ' is a code-runner. When it is run it looks for a configuration file or list of configuration files. Within each file it looks for an [ARACHNEAPE] section. Each entry in that section is interpreted to be a list of plugins to execute in top-down, left-right ordering.'
            self._sections["Configuration"] = CONFIGURATION
            self._sections['Examples'] = 'arachneape run *.ini\narachneape help\narachneape fetch\narachneape list\narachneape check *ini'
            self._sections['Errors'] = 'Nothing yet'
            self._sections['Files'] = __file__
        return self._sections
    
    @property
    def product(self):
        """
        this is a product
        """
        class Operator(DummyClass):
            def __init__(self, *args, **kwargs):
                super(Operator, self).__init__(*args, **kwargs)

        op_1 = Operator(name='op_1')
        op_2 = Operator(name='op_2')

        class BadOperator(Operator):
            def __init__(self, *args, **kwargs):
                super(BadOperator, self).__init__(*args, **kwargs)
                
            def __call__(self):
                raise OperatorError('this is an operator error')
            
        op_3 = BadOperator(name='op_3')
        exhort = TheHortator([op_1, op_2, op_3])
        return exhort

    def fetch_config(self):
        """
        Prints example configuration
        """
        print CONFIGURATION
# end class ArachnePlugin        
@

The Help
--------

To print the help-message the ArachneApe will use the help page, but since it is the default plugin it needs to construct things like the arguments and such. To keep it dynamic I am going to try and use the ArgumentParser instance. Here are the experiments.

.. currentmodule:: argparse
.. autosummary::
   
   argparse.ArgumentParser.format_usage

<<name='format_usage', wrap=False>>=
if output_documentation:
    arguments = ArgumentClinic()
    arguments.add_arguments()
    arguments.add_subparsers()
    parser = arguments.parser
    print parser.format_usage()
@

Well, that might be kind of useful, although the program name is wrong and it does not show the sub-parser arguments.

<<name='format_help', wrap=False>>=
if output_documentation:
    parser.prog = 'arachneape'
    print parser.format_help()
@

Not really... most of the arguments actually go to the sub-commands but they are not shown.

After stepping through the code it looks like this is going to be more effort than it is worth, the sub-parsers are themselves instances of ArgumentParser and that simple help message being printed is going through quite a bit of code to get built up. I think I will just write it out for now.

Another Way
~~~~~~~~~~~

After taking a break I decided to just add the sub-commands to the ArgumentClinic as properties, that way I can try to query them directly.

.. currentmodule:: arachneape.interface.arguments
.. autosummary::
   :toctree: api

   ArgumentClinic

<<name='sub_parser_queries', wrap=False>>=
if output_documentation:
    subs = (arguments.runner, arguments.fetcher,
            arguments.lister, arguments.checker, arguments.helper)

    program = 'arachneape[.\w]*'
    expression = re.compile(program)
    for sub in subs:
        print expression.sub('arachneape', sub.format_usage().replace('usage: ', ''))
@

The regular-expression substitution is to get rid of the extra package name while still keeping the sub-command, otherwise it says ``arachneape.interface``.
